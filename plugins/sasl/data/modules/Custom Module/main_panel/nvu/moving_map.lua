--[[
    This is PA-3 (ПА-3, Планшет Авиационный 3), the mechanical moving map tablet of NVU doppler nav system.
    It features a cursor that moves laterally (Z value) and a scrolling map (S value).
    The map scroll has texture size of 1142 pixels width and 20000 pixels height.
    The map rendering window is 1142x1236 pixels.

    PA-3 had route map divided in sections - route legs (for destination airports might have maps in two scales).
    Each section represents one route leg drawn vertically. NVU sends current S value, Z value and leg change signal.
    Z value moves pointer (left/right), S value moves map roll.
    When NVU switches legs (from manual or automatic mode), it sends a signal to PA-3,
    and PA-3 performs transition to another map segment.

    PA-3 distinguishes map segments via special marks on leg endings. In this implementation
    marks are stored in Configuration.Marks table as pixel offsets. When PA-3 is recoupled to NVU,
    it searches for the nearest markpoint and sets it as global offset.

    PA-3's map is procedurally generated. It is rendered to a render target texture and then
    displayed on the panel texture. The map is constructed from an entered flightplan. The NVU
    flightplan can be entered via UI. However it also has ability to have custom scrolls.

    Custom scrolls are stored in "root aircraft dir/pa3" folder. A custom scroll is a file with
    extension .png and name in format scroll_XX.png where XX is a two digit number from 01 to 99.
    The file should have size 1142x20000 pixels. There can be supplementary files with extension
    .txt and name in format scroll_XX.txt where XX is a two digit number from 01 to 99. These
    files contain additional information about the scroll, such as marks and other data.

    PA-3 also has the ability to render the current scroll to a file. This is done via
    command tu154b2/custom/nvu/pa3/save_scroll. This command is registered in the menu as "Save current scroll to image".
    The file is saved to the root aircraft dir/pa3 folder with name nvu_map.png.
    This can be useful for editing the autogenerated maps for adding underlaying maps, remarks, etc.

    PA-3 adds its own power consumption to the NVU power consumption. It accounts for cursor and scroll motors,
    leg change, and base draw. The power consumption is calculated as follows:
    BASE_CURRENT_DRAW + CURSOR_MOTOR_CURRENT * (cursor deflection / CURSOR_MAX) + SCROLL_MOTOR_CURRENT * (scroll velocity / SCROLL_VEL_MAX)
    LEG_CHANGE_CURRENT * (leg change signal / 1)

    If cursor reaches max deflection (±160km), Zmax lamp is lit.
]]

size = { 1142, 1236 }


-- TODO: Total code cleanup and refactor


-- Define frame time property
defineProperty("frame_time", globalPropertyf("tu154b2/custom/time/frame_time"))

defineProperty("nav_sel", globalPropertyi("tu154b2/custom/switchers/nav_select"))

-- Define NVU properties we need to read
defineProperty("nvu_active", globalPropertyi("tu154b2/custom/nvu/nvu_active"))             -- active NVU set (1 or 2)
defineProperty("nvu_mode", globalPropertyi("tu154b2/custom/nvu/nvu_mode"))                 -- NVU mode (0=off, 1=ready, 2=calculation, 3=correction)
defineProperty("nvu_changing_ort", globalPropertyi("tu154b2/custom/nvu/nvu_changing_ort")) -- leg change signal
defineProperty("nvu_cc", globalPropertyf("tu154b2/custom/nvu/nvu_cc"))                     -- NVU current consumption

-- Current values from NVU
defineProperty("current_Z1", globalPropertyf("tu154b2/custom/nvu/current_Z1"))        -- Z value for first route leg
defineProperty("current_S1", globalPropertyf("tu154b2/custom/nvu/current_S1"))        -- S value for first route leg
defineProperty("current_Z2", globalPropertyf("tu154b2/custom/nvu/current_Z2"))        -- Z value for second route leg
defineProperty("current_S2", globalPropertyf("tu154b2/custom/nvu/current_S2"))        -- S value for second route leg

defineProperty("sd75_on", globalPropertyi("tu154b2/custom/switchers/ovhd/sd75_1_on")) -- TODO: implement proper SD-67
defineProperty("ismaster", globalPropertyf("scp/api/ismaster"))
-- Utility: truncate a number to at most two decimal places (no rounding)
local function truncate2(num)
    return math.modf(num * 100) / 100
end
defineProperty("diss_groundspeed", globalPropertyf("tu154b2/custom/nvu/diss_groundspeed")) -- путевая скорость по ДИСС - km/h
defineProperty("diss_slip_angle", globalPropertyf("tu154b2/custom/nvu/diss_slip_angle"))   -- угол сноса по ДИСС
--delta_course_property = globalPropertyf("tu154b2/custom/nvu/delta_course")
effective_speed_property = createGlobalPropertyf("tu154b2/custom/nvu/effective_speed", 0.0)

cockpit_80s = globalPropertyi("sim/custom/b2/kontur_70th")

PA3_ENABLED = createGlobalPropertyi("tu154b2/custom/nvu/pa3/enabled", 0)
pa3_showscrollmenu = createGlobalPropertyi("tu154b2/custom/nvu/pa3/showscrollmenu", 0)

-- Power bus
defineProperty("bus27_volt_left", globalPropertyf("tu154b2/custom/elec/bus27_volt_left"))
defineProperty("bus36_volt_left", globalPropertyf("tu154b2/custom/elec/bus36_volt_left"))

local cursor_offset = 0
local scroll_offset = 0
local scroll_velocity = 0 -- mm/sec

-- Tuning constants for smooth movement
local SCROLL_ACCEL = 600    -- mm/sec^2, acceleration when button held
local SCROLL_FRICTION = 800 -- mm/sec^2, deceleration when button released
local SCROLL_VEL_MAX = 1000 -- mm/sec, maximum scroll speed
json = require("json")
local stb_stitch = require("stb_stitch")
MAP_END = 0

-- PA-3 scale modes
Modes = {
    Airdrome = 1, -- Airport/terminal area mode (larger scale)
    Enroute = 0,  -- Enroute mode (smaller scale)
}

nvu_switch = 0
nvu_switch_arm = 1
prev_pos = 0 -- Previous scroll position for leg change logic
customScrollList = {}
-- PA-3 properties and interface elements
PA3 = {
    Scroll = createGlobalPropertyf("tu154b2/custom/nvu/pa3/scroll", 0.0),          -- scroll position (map roll position)
    ScrollAnim = createGlobalPropertyf("tu154b2/custom/nvu/pa3/scroll_anim", 0.0), -- scroll position (map roll position)
    Cursor = createGlobalPropertyf("tu154b2/custom/nvu/pa3/cursor", 0.0),          -- cursor position -180 to 180 mm
    Mode = createGlobalPropertyi("tu154b2/custom/nvu/pa3/mode", 0),                -- mode (0=Airdrome, 1=Enroute)
    Power = createGlobalPropertyi("tu154b2/custom/nvu/pa3/power", 0),              -- power state
    CurrentLeg = createGlobalPropertyi("tu154b2/custom/nvu/pa3/current_leg", 1),   -- current route leg

    CursorPos = 0,
    ScrollPos = 0,
    Coupled = 0,  -- whether PA-3 is coupled to NVU
    FindMark = 0, -- whether PA-3 is finding markpoint

    AccumulatedDistance = 0,

    -- interface
    PowerSw = createGlobalPropertyi("tu154b2/custom/switchers/nvu/pa3/power_sw", 0),            -- power switch
    ModeSw = createGlobalPropertyi("tu154b2/custom/switchers/nvu/pa3/mode_sw", 0),              -- mode switch
    --ScrollManual = createGlobalPropertyf("tu154b2/custom/switchers/nvu/pa3/scroll_wheel", 0.0),
    CurLeftBtn = createGlobalPropertyi("tu154b2/custom/buttons/nvu/pa3/cursor_left_btn", 0),    -- cursor left button
    CurRightBtn = createGlobalPropertyi("tu154b2/custom/buttons/nvu/pa3/cursor_right_btn", 0),  -- cursor right button
    ReleaseBtn = createGlobalPropertyi("tu154b2/custom/buttons/nvu/pa3/release_btn", 0),        -- release button, this button recouples the tablet to NVU
    Zmax = createGlobalPropertyi("tu154b2/custom/nvu/pa3/zmax", 0),                             -- Z max lamp (lit when cursor reaches max deflection)

    ScrollDownBtn = createGlobalPropertyi("tu154b2/custom/buttons/nvu/pa3/scroll_down_btn", 0), -- scroll down button
    ScrollUpBtn = createGlobalPropertyi("tu154b2/custom/buttons/nvu/pa3/scroll_up_btn", 0),     -- scroll up button

    ScrollOffset = createGlobalPropertyf("tu154b2/custom/nvu/pa3/scroll_offset", 0.0),
    Configuration = {
        Marks = {} -- this table of numbers stores markpoints on the map roll. Recoupling will set the nearest markpoint as offset
    }
}

-- Constants
local CURSOR_MAX = 160          -- Maximum cursor deflection in mm
local SCROLL_MAX = 12000        -- Maximum scroll in mm (12 meters)
local MANUAL_SCROLL_SPEED = 100 -- Manual scroll speed in mm/sec when using buttons
local MANUAL_CURSOR_SPEED = 300 -- Manual cursor speed in mm/sec when using buttons

-- Power consumption constants
local BASE_CURRENT_DRAW = 0.05    -- Base current draw when powered (0.05A)
local CURSOR_MOTOR_CURRENT = 0.12 -- Current draw when cursor motor is active (0.12A)
local SCROLL_MOTOR_CURRENT = 0.18 -- Current draw when scroll motor is active (0.18A)
local LEG_CHANGE_CURRENT = 0.25   -- Current draw during leg change transition (0.25A)

-- State variables
local prev_leg_change = 0      -- Previous state of leg change signal
local leg_transition_timer = 0 -- Timer for leg transition animation
local prev_cursor_pos = 0      -- Previous cursor position for detecting movement
local prev_scroll_pos = 0      -- Previous scroll position for detecting movement


-- Render target for procedural map drawing




local PA3_MAP_WIDTH = 1142                       -- pixels, corresponds to 160km
local PA3_MAP_HEIGHT = 20000                     -- or as needed for your scrollable area
local PA3_MAP_SCALE_KM = PA3_MAP_WIDTH / 160 / 2 -- pixels per km
local PA3_SCALE_ALT = PA3_MAP_WIDTH / 40 / 2     -- "Airdrome"

local TILE_HEIGHT = 4096
local NUM_TILES = math.ceil(PA3_MAP_HEIGHT / TILE_HEIGHT)
local pa3_map_tiles = {}

-- offset of the mark from beginning of the map
local MARK_OFFSET = 51

-- Create the render target texture for the map
local pa3_map_rt = sasl.gl.createRenderTarget(PA3_MAP_WIDTH, PA3_MAP_HEIGHT)
local pa3_rt = sasl.gl.createRenderTarget(size[1], size[2])
local pa3_custom_scroll = nil

local pa3_shader = sasl.gl.createShaderProgram()
sasl.gl.loadShader(pa3_shader, "pa3_handdrawn_vert.glsl", SHADER_TYPE_VERTEX)
--sasl.gl.loadShader(pa3_shader, "pa3_handdrawn_frag.glsl", SHADER_TYPE_FRAGMENT)
sasl.gl.linkShaderProgram(pa3_shader)


local save_scroll_cmd = sasl.createCommand("tu154b2/custom/nvu/pa3/save_scroll", "Save scroll to image")
pa3_save_scroll = sasl.appendMenuItemWithCommand(pa3_menu, "Save current scroll to image", save_scroll_cmd)
sasl.registerCommandHandler(save_scroll_cmd, 0, function(phase)
    if phase == SASL_COMMAND_END then
        local path = sasl.getAircraftPath() .. "/pa3/nvu_map.png"

        -- pa3_map_tiles is array of render target IDs
        local ok, err = stb_stitch.stitchRenderTargets(
            path,
            pa3_map_tiles, -- array of render target IDs
            PA3_MAP_WIDTH, -- 1142
            TILE_HEIGHT,   -- e.g., 4096
            4              -- RGBA
        )

        if ok then
            sasl.logInfo("PA-3: Saved scroll to " .. path)
        else
            sasl.logWarning("PA-3: Failed to save scroll: " .. tostring(err))
        end
    end
end)

local cycle_scroll_left_cmd = sasl.createCommand("tu154b2/custom/nvu/pa3/cycle_scroll_left", "Cycle custom scrolls left")
local cycle_scroll_right_cmd = sasl.createCommand("tu154b2/custom/nvu/pa3/cycle_scroll_right",
    "Cycle custom scrolls right")
pa3_cycle_scroll_left = sasl.appendMenuItemWithCommand(pa3_menu, "Cycle custom scrolls left", cycle_scroll_left_cmd)
pa3_cycle_scroll_right = sasl.appendMenuItemWithCommand(pa3_menu, "Cycle custom scrolls right", cycle_scroll_right_cmd)
currentScrollIndex = 0

local function refreshCustomScrollList()
    local pa3_dir = sasl.getAircraftPath() .. "/pa3"
    customScrollList = {}
    local files = sasl.listFiles(pa3_dir)
    for _, entry in ipairs(files) do
        if entry.type == "file" and string.match(entry.name, "^scroll_%d%d%.png$") then
            table.insert(customScrollList, entry.name)
        end
    end
    table.sort(customScrollList)
end

local function activateCustomScroll(index)
    if #customScrollList == 0 then
        sasl.logInfo("PA-3: No custom scrolls found in /pa3 directory.")
        return
    end
    if index < 1 then index = #customScrollList end
    if index > #customScrollList then index = 1 end
    currentScrollIndex = index
    local scrollName = customScrollList[currentScrollIndex]
    local scrollPath = sasl.getAircraftPath() .. "/pa3/" .. scrollName
    if pa3_custom_scroll then
        sasl.gl.unloadTexture(pa3_custom_scroll)
        pa3_custom_scroll = nil
    end


    local ok, err = stb_stitch.loadToRenderTargets(
        scrollPath,
        pa3_map_tiles,
        PA3_MAP_WIDTH,
        TILE_HEIGHT
    )
    if ok then
        sasl.logInfo("PA-3: Loaded custom scroll from " .. scrollPath)
        -- load custom scroll metadata
        local metadataPath = sasl.getAircraftPath() .. "/pa3/" .. string.gsub(scrollName, "%.png$", ".json")
        local metadata_file = io.open(metadataPath, "r")
        if metadata_file then
            local metadata = json.decode(metadata_file:read("*all"))
            -- import marks
            PA3.Configuration.Marks = metadata.marks or {}
            sasl.logDebug("PA-3: Loaded custom scroll metadata for " .. scrollName)
            sasl.logDebug("PA-3: Marks: " .. table.concat(PA3.Configuration.Marks, ", "))
        else
            PA3.Configuration.Marks = {}
            sasl.logInfo("PA-3: No custom scroll metadata found for " .. scrollName)
        end

        PA3.isCustomScrollActive = true
        PA3.activeCustomScrollName = scrollName
        sasl.logInfo("PA-3: Activated custom scroll: " .. scrollName)
    else
        sasl.logWarning("PA-3: Failed to load scroll: " .. scrollName .. " " .. tostring(err))
        return
    end
end

sasl.registerCommandHandler(cycle_scroll_left_cmd, 0, function(phase)
    if phase == SASL_COMMAND_END then
        refreshCustomScrollList()
        if #customScrollList == 0 then return end
        local idx = currentScrollIndex or 1
        idx = idx - 1
        activateCustomScroll(idx)
    end
end)

sasl.registerCommandHandler(cycle_scroll_right_cmd, 0, function(phase)
    if phase == SASL_COMMAND_END then
        refreshCustomScrollList()
        if #customScrollList == 0 then return end
        local idx = currentScrollIndex or 1
        idx = idx + 1
        activateCustomScroll(idx)
    end
end)

local reset_cmd = sasl.createCommand("tu154b2/custom/nvu/pa3/reset_scroll", "Reset scroll to generated")
pa3_reset_scroll = sasl.appendMenuItemWithCommand(pa3_menu, "Reset scroll to generated", reset_cmd)
sasl.registerCommandHandler(reset_cmd, 0, function(phase)
    if phase == SASL_COMMAND_END then
        if pa3_custom_scroll then
            sasl.gl.unloadTexture(pa3_custom_scroll)
            pa3_custom_scroll = nil
        end
        PA3.isCustomScrollActive = false
        PA3.activeCustomScrollName = ""
        set(nvu_navplan_changed, 1)
        updateMarks()
    end
end)




-- Utility: clamp a value between min and max
local function clamp(val, minVal, maxVal)
    if val < minVal then return minVal end
    if val > maxVal then return maxVal end
    return val
end

-- Utility: linear interpolation
local function lerp(a, b, t)
    return a + (b - a) * clamp(t, 0, 1)
end

-- Utility: smoothstep interpolation
local function smoothStep(a, b, t)
    t = clamp((t - a) / (b - a), 0, 1)
    return t * t * (3 - 2 * t)
end

function findMark(next)
    PA3.ScrollPos = PA3.ScrollPos + MANUAL_SCROLL_SPEED

    if PA3.ScrollPos > SCROLL_MAX then
        PA3.ScrollPos = SCROLL_MAX
        PA3.FindMark = 0
    end

    local radius = 100 -- mm, adjust as needed
    local current_pos = PA3.ScrollPos

    for i = 1, #PA3.Configuration.Marks do
        local mark = PA3.Configuration.Marks[i] - MARK_OFFSET
        if math.abs(current_pos - mark) <= radius then
            if not (prev_pos ~= 0 and math.abs(current_pos - prev_pos) <= radius) then
                sasl.logDebug("Mark found at " .. mark .. " mm")
                set(PA3.ScrollOffset, mark)
                PA3.FindMark = 0
                PA3.Coupled = 1
                nvu_switch = 0
                prev_pos = 0
                break
            end
        end
    end
end

--handle leg change
function handleLegChange()
    sasl.logDebug("Leg change detected")
    PA3.AccumulatedDistance = 0
    prev_pos = PA3.ScrollPos
    PA3.Coupled = 0
    PA3.FindMark = 1
    nvu_switch = 1
end

function update()
    local MASTER = get(ismaster) ~= 1

    local passed = get(frame_time)

    if MASTER then
        updateSwitches()
        updateMarks()
    end

    -- Power logic
    local power_sw = get(PA3.PowerSw)
    local has_power = power_sw == 1 and get(bus27_volt_left) > 13 and get(bus36_volt_left) > 30 and get(cockpit_80s) == 0

    if MASTER then
        set(PA3.Power, has_power and 1 or 0)
    end

    -- Initialize current draw for PA-3
    local current_draw = 0

    -- Mode switch logic
    local mode_sw = get(PA3.ModeSw)
    if MASTER then
        set(PA3.Mode, mode_sw) -- Direct mapping of switch position to mode
    end

    if get(cockpit_80s) == 0 then
        set(nav_sel, 0) -- temporary crutch so that nav sel switch is always on NVU while 80s cockpit is selected
        set(sd75_on, 1) -- TODO: Implement SD75
    end
    has_power = true
    -- Only process if we have power
    if has_power then
        -- Add base current draw when powered
        current_draw = BASE_CURRENT_DRAW



        -- Get active NVU set and its values
        local active_set = get(nvu_active)
        local nvu_mode = get(nvu_mode)

        local current_z = 0
        local current_s = 0

        if MASTER then
            if PA3.FindMark == 1 then
                findMark()
            end
        end

        -- Select the appropriate Z and S values based on active NVU set
        if active_set == 1 then
            current_z = get(current_Z1)
            current_s = get(current_S1)
        else -- active_set == 2
            current_z = get(current_Z2)
            current_s = get(current_S2)
        end

        -- Process leg change signal
        local leg_change = get(nvu_changing_ort)
        if leg_change == 1 and nvu_switch == 0 and nvu_switch_arm == 1 then
            nvu_switch_arm = 0
            nvu_switch = 1
            handleLegChange()
        end

        if leg_change == 0 and nvu_switch_arm == 0 then
            nvu_switch_arm = 1
        end
        prev_leg_change = leg_change

        -- Update leg transition timer and add current draw during transition
        if leg_transition_timer > 0 then
            leg_transition_timer = leg_transition_timer - passed
            if leg_transition_timer < 0 then
                leg_transition_timer = 0
            end

            -- Add current draw for leg change motor (map section transition)
            current_draw = current_draw + LEG_CHANGE_CURRENT
        end

        if PA3.Coupled == 1 then
            local scale = PA3.Mode == Modes.Airdrome and PA3_SCALE_ALT or PA3_MAP_SCALE_KM

            PA3.CursorPos = (current_z + cursor_offset)
        end

        -- Release button logic
        local release_btn = get(PA3.ReleaseBtn)
        if release_btn == 1 then
            --PA3.Coupled = 1
            PA3.FindMark = 1
        end

        -- Apply manual cursor control from buttons
        local cur_left = get(PA3.CurLeftBtn)
        local cur_right = get(PA3.CurRightBtn)
        if cur_left == 1 then
            PA3.Coupled = 0
            PA3.CursorPos = PA3.CursorPos - MANUAL_CURSOR_SPEED * passed
        elseif cur_right == 1 then
            PA3.Coupled = 0
            PA3.CursorPos = PA3.CursorPos + MANUAL_CURSOR_SPEED * passed
        end

        -- Clamp cursor position to ±CURSOR_MAX



        -- Set cursor position smoothly


        -- Set Zmax lamp if cursor is at max deflection
        --
        if MASTER then
            if math.abs(PA3.CursorPos) >= CURSOR_MAX * 0.98 then -- 99% of max to account for floating point errors
                set(PA3.Zmax, 1)
            else
                set(PA3.Zmax, 0)
            end
        end


        -- Add current draw if cursor is moving
        if math.abs(PA3.CursorPos - prev_cursor_pos) > 0.01 then
            current_draw = current_draw + CURSOR_MOTOR_CURRENT
        end
        prev_cursor_pos = PA3.CursorPos

        -- Map NVU S value to scroll position (scaled to ±12m)
        -- S is already in km, so we scale it to mm (1km = 1000m = 1000000mm)
        local scroll_scale = SCROLL_MAX / 950      -- NVU S is limited to ±950
        local passed_dist = 0
        local speed = get(diss_groundspeed) / 3600 -- km/sec
        if PA3.Coupled == 1 then
            local scale = get(PA3.Mode) == Modes.Airdrome and PA3_SCALE_ALT or PA3_MAP_SCALE_KM
            -- Old S-based scroll (backup):
            --PA3.ScrollPos = get(PA3.ScrollOffset) + (current_s * scale)
            -- New: scroll moves by ground speed projected on track (using slip angle)
            --local ground_speed = get(diss_groundspeed)    -- km/h
            --local slip_angle = get(delta_course_property) -- degrees
            --local frame_time = passed                     -- seconds
            --local speed_kms = ground_speed / 3600
            --local effective_speed = speed_kms * math.cos(slip_angle)
            ----set(effective_speed_property, effective_speed)
            --PA3.AccumulatedDistance = PA3.AccumulatedDistance + effective_speed * frame_time
            PA3.ScrollPos = get(PA3.ScrollOffset) + (current_s * scale)
        end

        -- Smooth scroll control with acceleration/deceleration
        local scroll_down = get(PA3.ScrollDownBtn)
        local scroll_up = get(PA3.ScrollUpBtn)
        if scroll_down == 1 then
            PA3.Coupled = 0
            PA3.ScrollPos = PA3.ScrollPos - MANUAL_SCROLL_SPEED
        elseif scroll_up == 1 then
            PA3.Coupled = 0
            PA3.ScrollPos = PA3.ScrollPos + MANUAL_SCROLL_SPEED
        end





        -- Add current draw if scroll is moving
        if math.abs(PA3.ScrollPos - prev_scroll_pos) > 0.1 then
            current_draw = current_draw + SCROLL_MOTOR_CURRENT
        end
        prev_scroll_pos = PA3.ScrollPos

        -- Update the NVU current consumption
        -- We add our current to the existing NVU current consumption
        local nvu_current = get(nvu_cc)
        if MASTER then
            set(nvu_cc, nvu_current + current_draw)
        end

        if get(PA3.Mode) == Modes.Airdrome then
            PA3.CursorPos = PA3.CursorPos * 4
        end
        PA3.ScrollPos = clamp(PA3.ScrollPos, 600, MAP_END)
        PA3.CursorPos = clamp(PA3.CursorPos, -CURSOR_MAX, CURSOR_MAX)
    else
        -- No power, reset all values
        --PA3.ScrollPos = get(PA3.ScrollOffset)
        if MASTER then
            set(PA3.Zmax, 0)
        end
    end
    -- Set scroll position
    local scroll_anim = get(PA3.Scroll)
    scroll_anim = truncate2(scroll_anim + (PA3.ScrollPos - scroll_anim) * 0.1)
    if MASTER then
        set(PA3.Scroll, scroll_anim)
    end

    local cursor_anim = get(PA3.Cursor)
    cursor_anim = cursor_anim + (PA3.CursorPos - cursor_anim) * 0.1
    if MASTER then
        set(PA3.Cursor, cursor_anim)
    end

    drawMap()
end

function updateSwitches()
end

local gap = 580 * PA3_MAP_SCALE_KM
function drawMapBackground()
    sasl.gl.drawRectangle(0, 0, PA3_MAP_WIDTH, PA3_MAP_HEIGHT, { 1, 1, 1, 0.9 })
end

function drawMapTitle(y_offset)
    sasl.gl.saveInternalLineState()
    sasl.gl.setInternalLineWidth(15)
    sasl.gl.drawLine(0, 0, PA3_MAP_WIDTH, 0, { 0, 0, 0, 1 })
    sasl.gl.drawLine(0, y_offset - gap / 3, PA3_MAP_WIDTH, y_offset - gap / 3, { 0, 0, 0, 1 })
    sasl.gl.drawText(avia_font, 200, 200, "Н А Ч А Л О  К А Р Т Ы", 72, false, false, TEXT_ALIGN_LEFT, { 0, 0, 0, 1 })
    sasl.gl.drawText(avia_font, 20, 600, "Маршрутная карта. Масштаб 1:2000000", 52, false, false, TEXT_ALIGN_LEFT,
        { 0, 0, 0, 1 })
    --route name
    if nvu_navplan.Name and nvu_navplan.Name ~= "" then
        sasl.gl.drawText(avia_font, 20, 530, nvu_navplan.Name, 60, false, false, TEXT_ALIGN_LEFT, { 0, 0, 0, 1 })
    end
    if nvu_navplan.ShortDesc and nvu_navplan.ShortDesc ~= "" then
        sasl.gl.drawText(avia_font, 50, 480, nvu_navplan.ShortDesc, 42, false, false, TEXT_ALIGN_LEFT, { 0, 0, 0, 1 })
    end
    if nvu_navplan.LongDesc and nvu_navplan.LongDesc ~= "" then
        sasl.gl.drawText(avia_font, 50, 430, nvu_navplan.LongDesc, 32, false, false, TEXT_ALIGN_LEFT, { 0, 0, 0, 1 })
    end

    sasl.gl.restoreInternalLineState()
end

function drawLegSeparators(y_start, y_end)
    sasl.gl.saveInternalLineState()
    sasl.gl.setInternalLineWidth(15)
    sasl.gl.drawLine(0, (y_start - gap / 1.5), PA3_MAP_WIDTH, (y_start - gap / 1.5), { 0, 0, 0, 1 })
    sasl.gl.drawLine(0, (y_end + gap / 1.5), PA3_MAP_WIDTH, (y_end + gap / 1.5), { 0, 0, 0, 1 })
    sasl.gl.restoreInternalLineState()
end

function drawLegSegment(x, y_start, y_end)
    sasl.gl.saveInternalLineState()
    sasl.gl.setInternalLineWidth(15)
    sasl.gl.drawLine(x, y_start, x, y_end, { 0.6, 0, 0, 1 })
    sasl.gl.setInternalLineWidth(5)
    sasl.gl.drawCircle(x, y_start, 12, true, { 0, 0, 0, 1 })
    sasl.gl.drawCircle(x, y_end, 12, true, { 0, 0, 0, 1 })
    sasl.gl.drawCircle(x, y_end, 24, false, { 0, 0, 0, 1 })
    sasl.gl.restoreInternalLineState()
end

function drawLegLabels(x, y_start, y_end, i, leg)
    -- Draw waypoint names if available
    if leg.NAME and leg.NAME ~= "" then
        local start_wp, end_wp = string.match(leg.NAME, "([^-]+)-([^-]+)")
        if start_wp and end_wp then
            drawText(avia_font, x + 60, y_start + 20, start_wp, 48, false, false, TEXT_ALIGN_LEFT, { 0, 0, 0, 1 })
            drawText(avia_font, x + 60, y_end - 60, end_wp, 48, false, false, TEXT_ALIGN_LEFT, { 0, 0, 0, 1 })
        else
            drawText(avia_font, x - 300, y_start + 370, leg.NAME, 54, false, false, TEXT_ALIGN_LEFT, { 0, 0, 0, 1 })
        end
    end

    -- Show next leg's DTK, with DDDMM format below
    if nvu_navplan.Legs[i + 1] ~= nil then
        local dtk = nvu_navplan.Legs[i + 1].DTK or 0
        local degrees = math.floor(dtk)
        local minutes = math.floor((dtk - degrees) * 60 + 0.5)
        drawText(avia_font, x + 60, y_end + 20, "ЗПУ " .. tostring(dtk), 54, false, false, TEXT_ALIGN_LEFT,
            { 0, 0, 0, 1 })
        drawText(avia_font, x + 160, y_end + 60, string.format("%03d°%02d'", degrees, minutes), 40, false, false,
            TEXT_ALIGN_LEFT, { 0.4, 0.4, 0.2, 1 })
    end

    drawText(avia_font, x + 20, y_start + 20, tostring(i), 54, false, false, TEXT_ALIGN_LEFT, { 0, 0, 0, 1 })
    drawText(avia_font, x + 20, y_end - 60, tostring(i + 1), 54, false, false, TEXT_ALIGN_LEFT, { 0, 0, 0, 1 })

    -- Draw leg info (bearing, distance, etc)
    -- ЗПУ (DTK) and DDDMM format below
    local leg_dtk = leg.DTK or 0
    local leg_deg = math.floor(leg_dtk)
    local leg_min = math.floor((leg_dtk - leg_deg) * 60 + 0.5)
    -- draw a border around info block
    sasl.gl.saveInternalLineState()
    sasl.gl.setInternalLineWidth(5)
    sasl.gl.drawFrame(x - 320, y_start + 40, 300, 280, { 0, 0, 0, 1 })
    sasl.gl.drawRectangle(x - 320, y_start + 40, 300, 280, { 0, 0, 0, 0.3 })
    sasl.gl.restoreInternalLineState()
    drawText(avia_font, x - 300, y_start + 100, "ЗПУ = " .. tostring(leg_dtk), 54, false, false, TEXT_ALIGN_LEFT,
        { 0, 0, 0, 1 })
    drawText(avia_font, x - 160, y_start + 50, string.format("%03d°%02d'", leg_deg, leg_min), 40, false, false,
        TEXT_ALIGN_LEFT, { 0.4, 0.4, 0.2, 1 })
    drawText(avia_font, x - 300, y_start + 160, "S = " .. tostring(leg.S > 0 and -leg.S or leg.S), 54, false, false,
        TEXT_ALIGN_LEFT, { 0, 0, 0, 1 })
    drawText(avia_font, x - 300, y_start + 220, "Z = " .. tostring(leg.Z or 0), 54, false, false, TEXT_ALIGN_LEFT,
        { 0, 0, 0, 1 })
end

function drawLegMarkers(y_start, y_end, leg)
    sasl.gl.saveInternalLineState()
    sasl.gl.setInternalLineWidth(2)
    for _, v in pairs(PA3.Configuration.Marks) do
        sasl.gl.drawLine(0, v, PA3_MAP_WIDTH, v, { 0, 0, 0, 1 })
    end
    --sasl.gl.drawLine(0, y_end, PA3_MAP_WIDTH, y_end, { 0, 0, 0, 1 })
    sasl.gl.setInternalLineWidth(5)
    for i = 0, leg.S + 100, 10 do
        sasl.gl.drawLine(0, y_end - i * PA3_MAP_SCALE_KM, 20, y_end - i * PA3_MAP_SCALE_KM, { 0, 0, 0, 1 })
    end
    for i = 0, leg.S + 100, 100 do
        sasl.gl.drawLine(0, y_end - i * PA3_MAP_SCALE_KM, 140, y_end - i * PA3_MAP_SCALE_KM, { 0, 0, 0, 1 })
        drawText(avia_font, 145, y_end - i * PA3_MAP_SCALE_KM - 20, tostring(i), 60, false, false, TEXT_ALIGN_LEFT,
            { 0, 0, 0, 1 })
    end

    -- Draw the scale on the right side in nautical miles
    sasl.gl.setInternalLineWidth(5)
    for i = 0, leg.S + 100, 5 do      -- NM markers every 5 NM
        local nm_position = i * 1.852 -- Convert NM to km (1 NM = 1.852 km)
        sasl.gl.drawLine(PA3_MAP_WIDTH - 20, y_end - nm_position * PA3_MAP_SCALE_KM, PA3_MAP_WIDTH,
            y_end - nm_position * PA3_MAP_SCALE_KM, { 0.3, 0, 0, 1 })
    end
    for i = 0, leg.S + 100, 50 do     -- Major NM markers every 50 NM
        local nm_position = i * 1.852 -- Convert NM to km
        sasl.gl.drawLine(PA3_MAP_WIDTH - 52, y_end - nm_position * PA3_MAP_SCALE_KM, PA3_MAP_WIDTH,
            y_end - nm_position * PA3_MAP_SCALE_KM, { 0.3, 0, 0, 1 })
        drawText(avia_font, PA3_MAP_WIDTH - 72, y_end - nm_position * PA3_MAP_SCALE_KM - 20,
            tostring(i) .. " NM", 42, false, false, TEXT_ALIGN_RIGHT, { 0.3, 0, 0, 1 })
    end

    sasl.gl.restoreInternalLineState()
end

local prev_dx = 0
local prev_dy = 0
function drawLegCourseArrows(x, y_start, y_end, i, leg, next_DTK)
    if i == 1 then
        prev_dx = 0
        prev_dy = 0
    end
    sasl.gl.saveInternalLineState()
    local DTK = (leg.DTK or 0)
    local len = gap / 2.8

    -- Calculate angle between current leg and next leg
    local rel_angle = 0
    if i < #nvu_navplan.Legs then
        local next_leg = nvu_navplan.Legs[i + 1]
        if next_leg and next_leg.DTK and leg.DTK then
            -- Calculate the difference between current and next leg DTK
            rel_angle = (90 - leg.DTK) - (90 - (next_leg.DTK or 0))
            -- Normalize angle to -180 to 180 range
            while rel_angle > 180 do rel_angle = rel_angle - 360 end
            while rel_angle < -180 do rel_angle = rel_angle + 360 end
        end
    end

    --rel_angle = normalize_angle((90 -  DTK - next_DTK or 0))

    rel_angle = rel_angle - 90




    local relative_dtk = math.rad(rel_angle)
    --sasl.logDebug("rel_angle: " .. rel_angle)
    local dx = math.cos(relative_dtk) * len
    local dy = math.sin(relative_dtk) * len

    -- Draw arrow indicators for previous leg connection



    sasl.gl.setInternalLineWidth(7)
    if i < #nvu_navplan.Legs then
        sasl.gl.drawLine(x, y_end, x + dx, y_end - dy, { 0, 0, 0, 1 })
    end
    if i > 1 then
        sasl.gl.drawLine(x, y_start, x + prev_dx, y_start - -prev_dy, { 0, 0, 0, 1 })
    end
    sasl.gl.restoreInternalLineState()
    prev_dx = dx
    prev_dy = dy
end

function drawMapEnding(y_offset)
    sasl.gl.saveInternalLineState()
    sasl.gl.setInternalLineWidth(15)
    local ending_size = 400 * PA3_MAP_SCALE_KM
    sasl.gl.drawLine(0, y_offset + ending_size + 800, PA3_MAP_WIDTH, y_offset + ending_size + 800, { 0, 0, 0, 1 })
    sasl.gl.drawText(avia_font, PA3_MAP_WIDTH / 2, y_offset + ending_size + 400, "К О Н Е Ц  К А Р Т Ы", 72, false, false,
        TEXT_ALIGN_CENTER, { 0, 0, 0, 1 })
    sasl.gl.restoreInternalLineState()
    MAP_END = y_offset + ending_size + 800
end

-- returns scaled value in pixels


-- returns scaled value in pixels
local function scale(km)
    return km * PA3_MAP_SCALE_KM
end

local map_shader = sasl.gl.createShaderProgram()
sasl.gl.loadShader(map_shader, "pa3_handdrawn_vert.glsl", SHADER_TYPE_VERTEX)
--sasl.gl.loadShader(map_shader, "pa3_handdrawn_frag.glsl", SHADER_TYPE_FRAGMENT)
sasl.gl.linkShaderProgram(map_shader)

function drawMap()
    sasl.gl.setRenderTarget(pa3_map_rt)
    if PA3.isCustomScrollActive then
        return
    else
        -- Procedural: render each tile with offset
        for i = 1, NUM_TILES do
            sasl.gl.setRenderTarget(pa3_map_tiles[i])
            local tile_y_offset = (i - 1) * TILE_HEIGHT

            -- Set up translation so drawing at "world" coordinates
            -- maps correctly to this tile
            sasl.gl.saveGraphicsContext()
            sasl.gl.setTranslateTransform(0, -tile_y_offset)

            -- Draw full map content (clipping will discard out-of-bounds)
            --
            drawMapBackground()
            if nvu_navplan.Legs then
                local n = #nvu_navplan.Legs
                if n > 0 then
                    local y_offset = scale(400)
                    drawMapTitle(y_offset)
                    for i = 1, n do
                        local leg = nvu_navplan.Legs[i]
                        if leg then
                            local x = PA3_MAP_WIDTH / 2 + scale(leg.Z)
                            local y_start = y_offset
                            local y_end = y_start + scale(leg.S)
                            drawLegSeparators(y_start, y_end)
                            if i ~= #nvu_navplan.Legs or i == #nvu_navplan.Legs - 1 then
                                sasl.gl.setClipArea(0, ((y_start - (gap / 1.5)) + ((gap / 2) / 1.5)), PA3_MAP_WIDTH,
                                    (scale(leg.S)) + (gap / 1.5))
                            end

                            drawLegSegment(x, y_start, y_end)
                            drawLegLabels(x, y_start, y_end, i, leg)
                            drawLegMarkers(y_start, y_end, leg)
                            local next_DTK = 0
                            if i < #nvu_navplan.Legs - 1 then
                                next_DTK = (nvu_navplan.Legs[i + 1].DTK or 0)
                            end
                            drawLegCourseArrows(x, y_start, y_end, i, leg, next_DTK)

                            y_offset = y_end + gap
                            if i == #nvu_navplan.Legs then
                                drawMapEnding(y_end)
                            end
                            sasl.gl.resetClipArea()
                            if y_offset > PA3_MAP_HEIGHT then
                                PA3_MAP_HEIGHT = PA3_MAP_HEIGHT + 4096
                                sasl.logDebug("y_offset > PA3_MAP_HEIGHT, y_offset = " ..
                                    y_offset .. ", PA3_MAP_HEIGHT = " .. PA3_MAP_HEIGHT)
                            end
                        end
                    end
                end
            end
            sasl.gl.restoreGraphicsContext()
        end
        sasl.gl.restoreRenderTarget()
    end
    --sasl.gl.stopShaderProgram(map_shader)
end

function updateMarks()
    if nvu_navplan.Legs and get(nvu_navplan_changed) == 1 then
        sasl.logDebug("updating marks")
        PA3.Configuration.Marks = {}
        local y_offset = scale(400)
        for i = 1, #nvu_navplan.Legs do
            local leg = nvu_navplan.Legs[i]
            if leg then
                local y_start = y_offset
                local y_end = y_start + scale(leg.S)
                PA3.Configuration.Marks[i] = y_end
                y_offset = y_end + gap
            end
        end
        set(nvu_navplan_changed, 0)
    end
end

-- place custom marks on the map
function onMouseDown(component, x, y, button)
    if button == MB_LEFT then
        -- Ensure custom marks table exists
        if not PA3.Configuration.CustomMarks then
            PA3.Configuration.CustomMarks = {}
        end
        -- Calculate the map scroll position corresponding to the mouse Y
        -- y is relative to the component (panel window), 0 at bottom
        local map_height = size[2]
        local scroll_pos = get(PA3.Scroll)
        -- In draw(), ty = section_y_offset + texture_scroll_offset - map_height / 2
        -- So, to get the map Y at the mouse click:
        local map_y = scroll_pos + (y - map_height / 2)
        table.insert(PA3.Configuration.CustomMarks, map_y)
        sasl.logDebug(string.format("PA-3: Placed custom mark at map Y = %.1f (mouse y = %d)", map_y, y))
    end
end

function draw()
    if get(cockpit_80s) == 0 then -- we draw only if 80s variant is chosen, because the moving map overlaps the Kontur
        if isNonLitStage() then
            local scroll_pos = get(PA3.Scroll)
            local start_tile = math.floor((scroll_pos - size[2] / 2) / TILE_HEIGHT) + 1
            local end_tile = math.ceil((scroll_pos + size[2] / 2) / TILE_HEIGHT)

            for i = start_tile, end_tile do
                if i >= 1 and i <= NUM_TILES then
                    local tile_y = (i - 1) * TILE_HEIGHT
                    local local_y = tile_y - scroll_pos + size[2] / 2
                    sasl.gl.drawTexturePart(pa3_map_tiles[i],
                        0, local_y, size[1], TILE_HEIGHT,
                        0, 0, PA3_MAP_WIDTH, TILE_HEIGHT, { 1, 1, 1, 1 })
                end
            end
        end
    end
end

function onModuleInit()
    --updateMarks()
    for i = 1, NUM_TILES do
        pa3_map_tiles[i] = sasl.gl.createRenderTarget(PA3_MAP_WIDTH, TILE_HEIGHT)
    end
    sasl.logDebug("Tiles created")
    sasl.logDebug("Tiles num: " .. NUM_TILES)
    PA3.ScrollPos = 600
    stb_stitch:init()
end

function onModuleDone()
    for i = 1, NUM_TILES do
        sasl.gl.destroyRenderTarget(pa3_map_tiles[i])
    end
end
